<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>ReflexAI Admin Console</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #1e1e1e; 
            color: #e0e0e0; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            min-height: 100vh; 
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .admin-box { 
            background: #2d2d2d; 
            border-radius: 12px; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.4); 
            padding: 30px 35px; 
            width: 100%;
            max-width: 500px; 
            box-sizing: border-box;
        }
        .admin-box h2 { 
            margin-top: 0;
            margin-bottom: 25px; 
            color: #61dafb;
            text-align: center;
            font-size: 1.8em;
        }
        .admin-box form { 
            display: flex; 
            flex-direction: column; 
            gap: 15px; 
        }
        .admin-box input[type="password"],
        .admin-box input[type="text"] { 
            padding: 12px 15px; 
            border-radius: 6px; 
            border: 1px solid #4a4a4a; 
            background: #252525; 
            color: #e0e0e0; 
            font-size: 1em;
            outline: none;
        }
        .admin-box input[type="password"]:focus,
        .admin-box input[type="text"]:focus {
            border-color: #61dafb;
            box-shadow: 0 0 0 2px rgba(97, 218, 251, 0.3);
        }
        .admin-box button { 
            padding: 12px 15px; 
            background: #61dafb; /* Яркий акцентный цвет */
            color: #1e1e1e; /* Темный текст для контраста */
            border: none; 
            border-radius: 6px; 
            font-weight: 600; 
            cursor: pointer; 
            font-size: 1em;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .admin-box button:hover {
            background: #52c5e7;
        }
        .admin-box button:active {
            transform: translateY(1px);
        }
        .admin-console { margin-top: 25px; }
        .pending-list, .user-list { 
            margin: 0; 
            padding: 0; 
            list-style: none; 
        }
        .pending-list li, .user-list li { 
            background: #333333; 
            margin-bottom: 10px; 
            padding: 15px; 
            border-radius: 8px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            flex-wrap: wrap;
            gap: 10px;
        }
        .pending-list .info, .user-list .info { 
            flex: 1; 
            min-width: 150px; /* Чтобы текст не сжимался слишком сильно */
        }
        .pending-list .info b, .user-list .info b {
            color: #82e9ff;
        }
        .pending-list button, .user-list button, #refreshBtn, #refreshUsersBtn {
            margin-left: 0; /* Убрали левый отступ, используем gap */
            padding: 8px 12px;
            font-size: 0.9em;
        }
        .pending-list .accept-btn { background-color: #4CAF50; color: white;}
        .pending-list .reject-btn { background-color: #f44336; color: white;}
        .user-list .pro-btn.is-pro { background-color: #ff9800; color: white;} /* Оранжевый для "Снять Pro" */
        .user-list .pro-btn.not-pro { background-color: #4CAF50; color: white;} /* Зеленый для "Выдать Pro" */
        
        #refreshBtn, #refreshUsersBtn {
            display: block;
            width: 100%;
            margin-top: 15px;
            background-color: #555;
        }
         #refreshBtn:hover, #refreshUsersBtn:hover {
            background-color: #666;
        }

        .feedback { 
            color: #ff6b6b; /* Яркий красный для ошибок */
            min-height: 20px; 
            font-size: 0.9em; 
            text-align: center;
            margin-top: 10px;
        }
        hr {
            border: none;
            border-top: 1px solid #4a4a4a;
            margin: 25px 0;
        }
        h3 {
            color: #82e9ff;
            margin-bottom: 15px;
            border-bottom: 1px solid #4a4a4a;
            padding-bottom: 8px;
        }
        #monitorUrlForm {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #monitorUrlInput {
            flex: 1;
        }
    </style>
</head>
<body>
    <div class="admin-box">
        <h2>Админ-консоль ReflexAI</h2>
        <form id="adminLoginForm" autocomplete="off">
            <input type="password" id="adminPassInput" name="adminpass" placeholder="Пароль администратора" required>
            <button type="submit">Войти</button>
        </form>
        <div class="feedback" id="adminFeedback"></div>

        <div class="admin-console" id="adminConsole" style="display:none;">
            <h3>Ожидающие регистрации</h3>
            <ul class="pending-list" id="pendingList"></ul>
            <button id="refreshBtn">Обновить список ожидающих</button>
            <hr>

            <h3>Настройки мониторинга</h3>
            <form id="monitorUrlForm">
                <input type="text" id="monitorUrlInput" placeholder="URL для /data эндпоинта монитора">
                <button type="submit">Сохранить URL</button>
            </form>
            <div class="feedback" id="monitorUrlFeedback"></div>
            <hr>

            <h3>Пользователи (PRO статус)</h3>
            <ul class="user-list" id="userList"></ul>
            <button id="refreshUsersBtn">Обновить список пользователей</button>
            <div class="feedback" id="userListFeedback"></div>
        </div>
    </div>

    <script>
        const loginForm = document.getElementById('adminLoginForm');
        const adminPassInput = document.getElementById('adminPassInput');
        const feedback = document.getElementById('adminFeedback');
        const adminConsole = document.getElementById('adminConsole');
        
        const pendingList = document.getElementById('pendingList');
        const refreshBtn = document.getElementById('refreshBtn');
        
        const monitorUrlForm = document.getElementById('monitorUrlForm');
        const monitorUrlInput = document.getElementById('monitorUrlInput');
        const monitorUrlFeedback = document.getElementById('monitorUrlFeedback');

        const userList = document.getElementById('userList');
        const refreshUsersBtn = document.getElementById('refreshUsersBtn');
        const userListFeedback = document.getElementById('userListFeedback');

        let currentAdminPassword = null; // Будет хранить введенный пароль для последующих запросов

        loginForm.onsubmit = async (e) => {
            e.preventDefault();
            const pass = adminPassInput.value;
            feedback.textContent = 'Проверка...';

            try {
                // Отправляем пароль на сервер для проверки
                const response = await fetch('/api/admin/login-check', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ adminPassword: pass })
                });

                if (response.ok) {
                    currentAdminPassword = pass; // Сохраняем пароль для будущих запросов
                    loginForm.style.display = 'none';
                    feedback.textContent = '';
                    adminConsole.style.display = 'block';
                    afterAdminLogin();
                } else {
                    const errorData = await response.json().catch(() => ({ error: 'Неверный пароль или ошибка сервера' }));
                    feedback.textContent = errorData.error || 'Неверный пароль';
                    currentAdminPassword = null;
                }
            } catch (error) {
                console.error("Ошибка входа:", error);
                feedback.textContent = 'Ошибка сети при входе.';
                currentAdminPassword = null;
            }
        };

        // Общая функция для выполнения админских запросов
        async function fetchAdminAPI(endpoint, method = 'GET', body = null) {
            if (!currentAdminPassword) {
                throw new Error('Пароль администратора не установлен. Пожалуйста, войдите снова.');
            }
            const headers = {
                'Content-Type': 'application/json',
                // Вместо X-Admin-Secret в заголовке, будем передавать его в теле,
                // так как наш adminAuth middleware на сервере проверяет и тело.
                // Если бы middleware проверял только заголовок, то:
                // 'X-Admin-Secret': currentAdminPassword 
            };
            const options = { method, headers };
            if (body) {
                // Добавляем adminSecret в тело каждого запроса, если он есть
                options.body = JSON.stringify({ ...body, adminSecret: currentAdminPassword });
            } else if (method !== 'GET') {
                 options.body = JSON.stringify({ adminSecret: currentAdminPassword });
            }
            // Для GET запросов adminSecret не нужен в теле, он будет проверен если бы был в заголовке.
            // Но наш adminAuth проверяет и query/body, так что для GET он не нужен, если не передаем тело.
            // Однако, для единообразия и чтобы adminAuth точно сработал, можно добавить его как query параметр,
            // но это менее безопасно. Лучше для GET эндпоинтов, если они требуют adminSecret,
            // чтобы сервер ожидал его в заголовке X-Admin-Secret.
            // В нашем случае, GET эндпоинты (/api/admin/pending, /api/admin/users, /api/monitor-url)
            // защищены adminAuth, который проверяет req.body.adminSecret.
            // Это значит, что для GET запросов без тела, adminAuth не сработает как ожидается, если он ищет adminSecret в теле.
            // ИСПРАВЛЕНИЕ: adminAuth на сервере должен также проверять заголовки.
            // Пока что, для GET, мы не будем слать тело, и будем полагаться на то, что
            // серверный adminAuth настроен на проверку заголовков или что для GET он не нужен.
            // Обновленный server.js теперь проверяет X-Admin-Secret в заголовке.
            // Поэтому добавим его для всех типов запросов.
            headers['X-Admin-Secret'] = currentAdminPassword;


            const response = await fetch(endpoint, options);
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: `Ошибка сервера: ${response.status}` }));
                throw new Error(errorData.error || `Ошибка ${response.status}`);
            }
            // Для DELETE запросов или других, которые могут не возвращать JSON
            const contentType = response.headers.get("content-type");
            if (contentType && contentType.indexOf("application/json") !== -1) {
                return response.json();
            } else {
                return response.text(); // или просто { ok: true } если текст не важен
            }
        }


        async function loadPending() {
            pendingList.innerHTML = '<li>Загрузка...</li>';
            try {
                const data = await fetchAdminAPI('/api/admin/pending');
                pendingList.innerHTML = '';
                if (!data.length) {
                    pendingList.innerHTML = '<li>Нет ожидающих регистраций</li>';
                    return;
                }
                for (const user of data) {
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="info"><b>${user.username}</b> (${user.displayName})</span>
                        <div>
                            <button class="accept-btn">Принять</button>
                            <button class="reject-btn">Отклонить</button>
                        </div>`;
                    li.querySelector('.accept-btn').onclick = () => handleUserAction(user.username, true);
                    li.querySelector('.reject-btn').onclick = () => handleUserAction(user.username, false);
                    pendingList.appendChild(li);
                }
            } catch (e) {
                pendingList.innerHTML = `<li>Ошибка загрузки: ${e.message}</li>`;
                console.error("Ошибка загрузки pending:", e);
            }
        }

        async function handleUserAction(username, accept) {
            feedback.textContent = 'Обработка...';
            try {
                await fetchAdminAPI('/api/admin/approve', 'POST', { username, accept });
                feedback.textContent = `Пользователь ${username} ${accept ? 'принят' : 'отклонен'}.`;
                loadPending(); // Обновить список
            } catch (e) {
                feedback.textContent = `Ошибка: ${e.message}`;
                console.error("Ошибка действия над пользователем:", e);
            }
        }

        refreshBtn.onclick = loadPending;

        async function loadMonitorUrl() {
            monitorUrlFeedback.textContent = '';
            try {
                const data = await fetchAdminAPI('/api/monitor-url');
                monitorUrlInput.value = data.monitorUrl || '';
            } catch (e) {
                monitorUrlFeedback.textContent = `Ошибка загрузки URL: ${e.message}`;
                console.error("Ошибка загрузки monitor URL:", e);
            }
        }

        monitorUrlForm.onsubmit = async (e) => {
            e.preventDefault();
            monitorUrlFeedback.textContent = 'Сохранение...';
            const url = monitorUrlInput.value.trim();
            if (!url) {
                monitorUrlFeedback.textContent = 'Введите ссылку';
                return;
            }
            try {
                await fetchAdminAPI('/api/monitor-url', 'POST', { monitorUrl: url });
                monitorUrlFeedback.textContent = 'Ссылка сохранена!';
            } catch (e) {
                monitorUrlFeedback.textContent = `Ошибка сохранения: ${e.message}`;
                console.error("Ошибка сохранения monitor URL:", e);
            }
        };

        async function loadUsers() {
            userList.innerHTML = '<li>Загрузка...</li>';
            userListFeedback.textContent = '';
            try {
                const data = await fetchAdminAPI('/api/admin/users');
                userList.innerHTML = '';
                if (!data.length) {
                    userList.innerHTML = '<li>Нет пользователей</li>';
                    return;
                }
                for (const user of data) {
                    const li = document.createElement('li');
                    const proButtonClass = user.isPro ? 'is-pro' : 'not-pro';
                    li.innerHTML = `<span class="info"><b>${user.username}</b> (${user.displayName}) 
                        <span style="color:${user.isPro ? '#76ff03' : '#ff6b6b'};font-weight:600;margin-left:8px;">${user.isPro ? 'PRO' : 'FREE'}</span>
                    </span>
                    <button class="pro-btn ${proButtonClass}">
                        ${user.isPro ? 'Снять Pro' : 'Выдать Pro'}
                    </button>`;
                    li.querySelector('.pro-btn').onclick = () => handleProAction(user.username, !user.isPro);
                    userList.appendChild(li);
                }
            } catch (e) {
                userList.innerHTML = `<li>Ошибка загрузки: ${e.message}</li>`;
                userListFeedback.textContent = `Ошибка загрузки пользователей: ${e.message}`;
                console.error("Ошибка загрузки пользователей:", e);
            }
        }

        async function handleProAction(username, setPro) {
            userListFeedback.textContent = 'Обновление статуса Pro...';
            try {
                await fetchAdminAPI('/api/admin/setpro', 'POST', { username, isPro: setPro });
                userListFeedback.textContent = `Статус Pro для ${username} ${setPro ? 'выдан' : 'снят'}!`;
                loadUsers(); // Обновить список
            } catch (e) {
                userListFeedback.textContent = `Ошибка обновления Pro: ${e.message}`;
                console.error("Ошибка обновления Pro статуса:", e);
            }
        }

        refreshUsersBtn.onclick = loadUsers;

        function afterAdminLogin() {
            loadPending();
            loadMonitorUrl();
            loadUsers();
        }
    </script>
</body>
</html>
